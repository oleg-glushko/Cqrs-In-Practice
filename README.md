[CQRS in Practice](https://www.pluralsight.com/courses/cqrs-in-practice) Pluralsight course's examples rewritten in .NET 8.

At the beginning of section 2, Vladimir said: "Also note that although it's a desktop application, it could very well be a web one, written in JavaScript." I decided to drop WPF and instead create UI in Blazor using the new .NET 8 [auto renderer mode](https://learn.microsoft.com/en-us/aspnet/core/blazor/components/render-modes?view=aspnetcore-8.0). It runs both on a server and in a browser, so `HttpClient` should point to the API URI in Ui and Api (it also serves as a Blazor Server Host) projects. In the former, this is made automatically through the builder's `HostEnvironment.BaseAddress` property. In the latter, you might need to update the "APIBaseAddress" entry in appsettings.json. 

I use the current version of the EF Core framework instead of NHibernate. It'd introduced quite a few enhancements through these years. For example, now it's possible to filter on many-to-many relations without materializing a full graph locally beforehand. Also, as ORM implements a Unit of Work pattern, I didn't recreate it in my class. However, repository classes are here even though ORM is also a repository. I made them to keep the project closer to the course's structure. Due to this decision, Lazy Loading won't work for queries prolonged between two repositories, so I switched to AutoInclude instead.

Before running any of these projects, create a database (all but the last example have one .sql script in their root) and adjust a connection string (two strings for the final project) in appsettings.json.
